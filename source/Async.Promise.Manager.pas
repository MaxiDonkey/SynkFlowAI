/// <summary>
/// The <c>Async.Promise.Manager</c> unit provides core classes and functionality for managing
/// asynchronous operations using a promise-based approach in Delphi.
/// </summary>
/// <remarks>
/// <para>
/// This unit defines several key components:
/// </para>
/// <para>
/// - <c>TDelegateError</c>: A delegate type for handling error messages during asynchronous execution.
/// </para>
/// <para>
/// - <c>TPromiseParams</c>: An extension of the generic parameter manager that offers a fluent interface
///   for configuring asynchronous operations, such as setting input, model, output type, and other settings.
/// </para>
/// <para>
/// - <c>TOutputType</c> and its helper: Enumerations and associated methods to specify and manage the output format.
/// </para>
/// <para>
/// - <c>TChainOfThought</c> and <c>TChainOfThoughts</c>: Classes for structuring a chain-of-thought process,
///   which aids in multi-step reasoning.
/// </para>
/// <para>
/// - <c>TPromiseEvents</c>: An abstract class that outlines essential events for promise execution,
///   including pre-execution, post-execution, and the execution process.
/// </para>
/// <para>
/// - <c>TPipeline</c>: A class that aggregates a series of <c>TPromiseParams</c> instances representing
///   the individual steps in an asynchronous processing pipeline.
/// </para>
/// <para>
/// Collectively, these components provide a flexible framework for constructing and managing complex
/// asynchronous workflows, enabling both sequential and parallel execution, dynamic parameter cloning,
/// and structured error handling.
/// </para>
/// </remarks>
unit Async.Promise.Manager;

interface

uses
  System.SysUtils, System.Generics.Collections, System.Classes,
  Async.Promise, ASync.Promise.Params;

{$SCOPEDENUMS ON}

type
  /// <summary>
  /// Represents a delegate type for handling error messages in asynchronous operations.
  /// </summary>
  /// <param name="Value">
  /// A string containing the error message.
  /// </param>
  TDelegateError = reference to procedure (Value: string);

  TPromiseParams = class;

  TEnumValueRecovery = class
    class function TypeRetrieve<T>(const Value: string; const References: TArray<string>): T;
  end;

  /// <summary>
  /// Specifies the output format type for asynchronous processing.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>TOutputType</c> enumeration defines how the output generated by the asynchronous pipeline
  /// is formatted. This setting is used to control whether the final result is structured as containerless
  /// JSON with descriptive field names, or if no special formatting should be applied.
  /// </para>
  /// <para>
  /// Use <c>json</c> for JSON-formatted output and <c>none</c> when no output formatting is required.
  /// </para>
  /// </remarks>
  TOutputType = (
    json,
    none
  );

  TOutputTypeHelper = record Helper for TOutputType
    constructor Create(const Value: string);
    function ToString: string;
    function ToContent: string;
  end;

  TProcessingMode = (
    web_normal,
    web_parallel,
    parallel,
    default
  );

  TProcessingModeHelper = record Helper for TProcessingMode
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// The <c>TChainOfThought</c> class encapsulates a single reasoning step within a chain-of-thought process.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class stores a text fragment that represents an individual step in a multi-step reasoning
  /// or decision-making process. It is intended to be used as part of a collection that forms a complete
  /// chain-of-thought, enabling structured and incremental problem solving.
  /// </para>
  /// <para>
  /// The class provides a class function <c>New</c> for convenient instantiation with a given content value.
  /// </para>
  /// </remarks>
  TChainOfThought = class
  private
    FContent: string;
  public
    /// <summary>
    /// Gets or sets the content of the chain-of-thought step.
    /// </summary>
    property Content: string read FContent write FContent;
    /// <summary>
    /// Creates a new instance of <c>TChainOfThought</c> with the specified content.
    /// </summary>
    /// <param name="Content">
    /// The text representing the thought or reasoning step.
    /// </param>
    /// <returns>
    /// A new instance of <c>TChainOfThought</c> initialized with the provided content.
    /// </returns>
    class function New(const Content: string): TChainOfThought;
  end;

  /// <summary>
  /// The <c>TChainOfThoughts</c> class represents a collection of individual chain-of-thought steps.
  /// It is a specialized <c>TObjectList&lt;TChainOfThought&gt;</c> that is used to store and manage the reasoning
  /// steps generated during multi-step asynchronous processing.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class provides a convenient way to aggregate multiple <c>TChainOfThought</c> instances,
  /// enabling easy iteration, addition, and removal of reasoning steps throughout the processing pipeline.
  /// </para>
  /// <para>
  /// The constructor of <c>TChainOfThoughts</c> ensures that the instance is automatically registered
  /// for memory management within the asynchronous framework.
  /// </para>
  /// </remarks>
  TChainOfThoughts = class(TObjectList<TChainOfThought>)
    constructor Create; reintroduce;
  end;

  // <summary>
  /// The <c>TPromiseEvents</c> class is an abstract base class that defines the essential events
  /// for asynchronous promise execution.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class establishes the structure for handling key events in the lifecycle of a promise.
  /// Derived classes must override the abstract methods <c>BeforeExec</c>, <c>AfterExec</c>, and
  /// <c>Execute</c> to implement custom behavior for pre-execution, post-execution, and the execution
  /// process itself.
  /// </para>
  /// <para>
  /// By providing this abstraction, <c>TPromiseEvents</c> facilitates a modular design where different
  /// event handling strategies can be implemented, allowing for flexible integration into asynchronous
  /// workflows.
  /// </para>
  /// </remarks>
  TPromiseEvents = class abstract
  protected
    FOwner: TPromiseParams;
  public
    /// <summary>
    /// Abstract method that is called before executing the asynchronous task.
    /// </summary>
    /// <returns>
    /// A string representing the pre-execution prompt or any initial message.
    /// </returns>
    function BeforeExec: string; virtual; abstract;
    /// <summary>
    /// Abstract method that is called after the asynchronous task has completed.
    /// </summary>
    /// <param name="Value">
    /// The output or result from the asynchronous task.
    /// </param>
    /// <returns>
    /// A string representing the processed output.
    /// </returns>
    function AfterExec(Value: string): string; virtual; abstract;
    /// <summary>
    /// Abstract method that executes the asynchronous operation and returns a promise.
    /// </summary>
    /// <returns>
    /// A <c>TPromise&lt;string&gt;</c> that will eventually be fulfilled with the result of the asynchronous task.
    /// </returns>
    function Execute: TPromise<string>; virtual; abstract;
    /// <summary>
    /// Creates a new instance of <c>TPromiseEvents</c> and associates it with the specified owner parameters.
    /// </summary>
    /// <param name="AOwner">
    /// The <c>TPromiseParams</c> instance that owns this event handler.
    /// </param>
    constructor Create(AOwner: TPromiseParams); overload;
    /// <summary>
    /// Creates a new instance of <c>TPromiseEvents</c> using a parameter configuration callback.
    /// </summary>
    /// <param name="ParamProc">
    /// A callback that receives a <c>TPromiseParams</c> instance for configuration.
    /// </param>
    constructor Create(ParamProc: TProc<TPromiseParams>); overload;
  end;

  /// <summary>
  /// The <c>TPromiseParams</c> class extends <c>TParameters</c> to provide a fluent interface
  /// for configuring asynchronous operations in a promise-based pipeline.
  /// </summary>
  /// <remarks>
  /// <para>
  /// TPromiseParams is designed to manage key-value pairs for asynchronous task configuration.
  /// It supports setting parameters such as input text, model selection, output format, client information,
  /// and other execution settings necessary for chaining asynchronous operations.
  /// </para>
  /// <para>
  /// In addition to the basic functionality inherited from <c>TParameters</c>, TPromiseParams offers methods
  /// for cloning parameter sets, associating event handlers, and integrating with the processing pipeline.
  /// This ensures a consistent and reusable approach for managing configuration data across different stages
  /// of an asynchronous workflow.
  /// </para>
  /// <code>
  /// var
  ///   Params: TPromiseParams;
  /// begin
  ///   Params := TPromiseParams.Create;
  ///   Params.Input('What is the impact of climate change?')
  ///         .Model('gpt-4o-mini')
  ///         .OutputType('json')
  ///         .Client(MyAIClient)
  ///         .SilentMode(False);
  ///   // The configured Params can now be used in the asynchronous execution pipeline.
  /// end;
  /// </code>
  /// </remarks>
  TPromiseParams = class(TParameters)
  const
    S_CHAINSTEPS = 'chainsteps';
    S_CLIENT = 'client';
    S_EVENT = 'event';
    S_INDEX = 'index';
    S_INPUT = 'input';
    S_MODEL = 'model';
    S_OUTPUT = 'output';
    S_OUPUTTYPE = 'outputtype';
    S_PIPELINE = 'pipeline';
    S_PROCESSINGMODE = 'processingmode';
    S_SILENTMODE = 'silentmode';
  private
    FStreamBuffer: string;
  public
    /// <summary>
    /// Clones the current TPromiseParams instance and assigns a new index to the clone.
    /// </summary>
    /// <param name="NewIndex">
    /// The new index value to set in the cloned instance.
    /// </param>
    /// <returns>
    /// A new TPromiseParams instance with the updated index.
    /// </returns>
    function CloneWithIndex(const NewIndex: Integer): TPromiseParams;
    /// <summary>
    /// Creates a shallow copy of the current TPromiseParams instance.
    /// </summary>
    /// <param name="AOwnsObjects">
    /// A Boolean flag indicating whether the cloned instance should take ownership of object references. Defaults to True.
    /// </param>
    /// <returns>
    /// A new TPromiseParams instance that is a shallow copy of the current instance.
    /// </returns>
    function Clone(AOwnsObjects: Boolean = True): TPromiseParams;
    /// <summary>
    /// Associates a chain-of-thought steps object with the parameter set.
    /// </summary>
    /// <param name="Value">
    /// The object representing the chain-of-thought steps.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function ChainSteps(const Value: TObject): TPromiseParams;
    /// <summary>
    /// Associates a client interface with the parameter set.
    /// </summary>
    /// <param name="Value">
    /// The client interface instance.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Client(const Value: IInterface): TPromiseParams;
    /// <summary>
    /// Associates an event handler object with the parameter set.
    /// </summary>
    /// <param name="Value">
    /// The event handler object, typically an instance derived from TPromiseEvents.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Events(const Value: TObject): TPromiseParams;
    /// <summary>
    /// Sets the index value for the parameter set.
    /// </summary>
    /// <param name="Value">
    /// The index value to set.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Index(const Value: Integer): TPromiseParams;
    /// <summary>
    /// Sets the input text for the asynchronous operation.
    /// </summary>
    /// <param name="Value">
    /// The input string.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Input(const Value: string): TPromiseParams;
    /// <summary>
    /// Specifies the model to be used for the asynchronous operation.
    /// </summary>
    /// <param name="Value">
    /// The model name as a string.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Model(const Value: string): TPromiseParams;
    /// <summary>
    /// Sets the output text produced by the asynchronous operation.
    /// </summary>
    /// <param name="Value">
    /// The output string.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Output(const Value: string): TPromiseParams;
    /// <summary>
    /// Sets the output type using a string representation (e.g., 'json' or 'none').
    /// </summary>
    /// <param name="Value">
    /// The output type as a string.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function OutputType(const Value: string): TPromiseParams; overload;
    /// <summary>
    /// Sets the output type using a <c>TOutputType</c> enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The output type as a <c>TOutputType</c> value.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function OutputType(const Value: TOutputType): TPromiseParams; overload;
    /// <summary>
    /// Associates a pipeline object with the parameter set.
    /// </summary>
    /// <param name="Value">
    /// The pipeline object, typically a TPipeline instance.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function Pipeline(const Value: TObject): TPromiseParams;
    /// <summary>
    /// Sets the processing mode for the asynchronous operation using a <c>TProcessingMode</c> enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The <c>TProcessingMode</c> value indicating the desired processing mode (such as <c>web_normal</c>, <c>web_parallel</c>, <c>parallel</c>, or <c>default</c>).
    /// </param>
    /// <returns>
    /// The updated <c>TPromiseParams</c> instance to allow method chaining.
    /// </returns>
    function ProcessingMode(const Value: TProcessingMode): TPromiseParams; overload;
    /// <summary>
    /// Sets the processing mode for the asynchronous operation using a string value.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired processing mode. Expected values include 'web_normal', 'web_parallel', 'parallel', or 'default'.
    /// </param>
    /// <returns>
    /// The updated <c>TPromiseParams</c> instance to allow method chaining.
    /// </returns>
    function ProcessingMode(const Value: string): TPromiseParams; overload;
    /// <summary>
    /// Sets the silent mode flag for the asynchronous operation.
    /// </summary>
    /// <param name="Value">
    /// A Boolean indicating whether silent mode should be enabled.
    /// </param>
    /// <returns>
    /// The updated TPromiseParams instance to allow method chaining.
    /// </returns>
    function SilentMode(const Value: Boolean): TPromiseParams;

    /// <summary>
    /// Retrieves the chain-of-thought steps associated with the parameter set.
    /// </summary>
    /// <returns>
    /// A TChainOfThoughts instance containing the reasoning steps, or nil if not set.
    /// </returns>
    function GetChainSteps: TChainOfThoughts;
    /// <summary>
    /// Retrieves the client interface associated with the parameter set.
    /// </summary>
    /// <typeparam name="T">
    /// The expected interface type.
    /// </typeparam>
    /// <returns>
    /// An instance of the client interface, or nil if not set.
    /// </returns>
    function GetClient<T: IInterface>: T;
    /// <summary>
    /// Retrieves the event handler associated with the parameter set.
    /// </summary>
    /// <returns>
    /// A TPromiseEvents instance representing the event handler, or nil if not set.
    /// </returns>
    function GetEvents: TPromiseEvents;
    /// <summary>
    /// Retrieves the index value of the parameter set.
    /// </summary>
    /// <returns>
    /// An integer representing the index, or -1 if not set.
    /// </returns>
    function GetIndex: Integer;
    /// <summary>
    /// Retrieves the input text from the parameter set.
    /// </summary>
    /// <returns>
    /// A string containing the input text.
    /// </returns>
    function GetInput: string;
    /// <summary>
    /// Retrieves the model name from the parameter set.
    /// </summary>
    /// <returns>
    /// A string representing the model name.
    /// </returns>
    function GetModel: string;
    /// <summary>
    /// Retrieves the output text from the parameter set.
    /// </summary>
    /// <returns>
    /// A string containing the output text.
    /// </returns>
    function GetOutput: string;
    /// <summary>
    /// Retrieves the output type from the parameter set as a <c>TOutputType</c> enumeration.
    /// </summary>
    /// <returns>
    /// A <c>TOutputType</c> value indicating the format of the output.
    /// </returns>
    function GetOutputType: TOutputType;
    /// <summary>
    /// Retrieves the pipeline associated with the parameter set.
    /// </summary>
    /// <returns>
    /// A TObjectList&lt;TPromiseParams&gt; representing the pipeline steps, or nil if not set.
    /// </returns>
    function GetPipeline: TObjectList<TPromiseParams>;
    /// <summary>
    /// Retrieves the current processing mode for the asynchronous operation.
    /// </summary>
    /// <returns>
    /// A <c>TProcessingMode</c> enumeration value representing the set processing mode.
    /// </returns>
    function GetProcessingMode: TProcessingMode;
    /// <summary>
    /// Retrieves the silent mode flag from the parameter set.
    /// </summary>
    /// <returns>
    /// A Boolean indicating whether silent mode is enabled.
    /// </returns>
    function GetSilentMode: Boolean;
    /// <summary>
    /// Gets or sets the internal stream buffer used for accumulating streaming data.
    /// </summary>
    property StreamBuffer: string read FStreamBuffer write FStreamBuffer;
  end;

  /// <summary>
  /// The <c>TPipeline</c> class manages a sequence of asynchronous step parameters by
  /// inheriting from <c>TObjectList&lt;TPromiseParams&gt;</c>. It is designed to aggregate
  /// and organize the configuration for each step in an asynchronous processing pipeline.
  /// </summary>
  /// <remarks>
  /// <para>
  /// TPipeline is primarily used to collect instances of <c>TPromiseParams</c> that represent
  /// each individual step of a chain-of-thought or multi-step asynchronous operation. It provides
  /// functionality to aggregate the outputs from these steps into a single, final result.
  /// </para>
  /// <para>
  /// The class includes the method <c>AggregatedOutput</c>, which concatenates the output from
  /// each step and can format it according to the provided parameters. This is especially useful
  /// when constructing a comprehensive response from a series of asynchronous tasks.
  /// </para>
  /// </remarks>
  TPipeline = class(TObjectList<TPromiseParams>)
  public
    /// <summary>
    /// Aggregates the output from each step in the pipeline into a single result string.
    /// </summary>
    /// <param name="isNew">
    /// A Boolean flag indicating whether a new formatted output should be generated. When set to True,
    /// the first step's input is used to create an initial JSON structure.
    /// </param>
    /// <returns>
    /// A string that contains the aggregated output from all pipeline steps.
    /// </returns>
    function AggregatedOutput(isNew: Boolean = True): string;
    constructor Create; reintroduce;
  end;

var
  /// <summary>
  /// Represents the default error handling delegate invoked during ancillary processing when an error is encountered.
  /// </summary>
  /// <remarks>
  /// This variable, <c>MainDelegateError</c>, is used as the default delegate to manage error behavior across various
  /// asynchronous operations. It ensures that any error encountered during additional processing is handled in a
  /// consistent and centralized manner.
  /// </remarks>
  MainDelegateError: TDelegateError = nil;

implementation

uses
  System.StrUtils, System.Rtti, System.TypInfo;

{ TPromiseParams }

function TPromiseParams.ChainSteps(const Value: TObject): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_CHAINSTEPS, Value));
end;

function TPromiseParams.Client(
  const Value: IInterface): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_CLIENT, Value));
end;

function TPromiseParams.Clone(AOwnsObjects: Boolean): TPromiseParams;
var
  Pair: TPair<string, TValue>;
begin
  {--- Create a new instance (choose the AOwnsObjects option depending on the context) }
  Result := TPromiseParams.Create(AOwnsObjects);
  for Pair in FParams do
    {--- Here we perform a shallow copy: simple types are copied, for objects, it is
         the reference that is copied }
    Result.FParams.AddOrSetValue(Pair.Key, Pair.Value);
end;

function TPromiseParams.CloneWithIndex(const NewIndex: Integer): TPromiseParams;
begin
  Result := Self.Clone;
  Result.Index(NewIndex);
end;

function TPromiseParams.Events(const Value: TObject): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_EVENT, Value));
end;

function TPromiseParams.GetChainSteps: TChainOfThoughts;
begin
  try
    Result := GetObject<TChainOfThoughts>(S_CHAINSTEPS);
  except
    Result := nil;
  end;
end;

function TPromiseParams.GetClient<T>: T;
begin
  Result := GetInterface<T>(S_CLIENT);
end;

function TPromiseParams.GetEvents: TPromiseEvents;
begin
  Result := GetObject<TPromiseEvents>(S_EVENT);
end;

function TPromiseParams.GetIndex: Integer;
begin
  try
    Result := GetInteger(S_INDEX);
  except
    Result := -1;
  end;
end;

function TPromiseParams.GetInput: string;
begin
  Result := GetString(S_INPUT);
end;

function TPromiseParams.GetOutput: string;
begin
  Result := GetString(S_OUTPUT);
end;

function TPromiseParams.GetPipeline: TObjectList<TPromiseParams>;
begin
  Result := GetObject<TObjectList<TPromiseParams>>(S_PIPELINE);
end;

function TPromiseParams.GetProcessingMode: TProcessingMode;
begin
  Result := TProcessingMode.Create(GetString(S_PROCESSINGMODE));
end;

function TPromiseParams.GetSilentMode: Boolean;
begin
  Result := GetBoolean(S_SILENTMODE, False);
end;

function TPromiseParams.GetModel: string;
begin
  Result := GetString(S_MODEL);
end;

function TPromiseParams.GetOutputType: TOutputType;
begin
  Result := TOutputType.Create(GetString(S_OUPUTTYPE));
end;

function TPromiseParams.Index(const Value: Integer): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_INDEX, Value));
end;

function TPromiseParams.Input(const Value: string): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_INPUT, Value));
end;

function TPromiseParams.Output(const Value: string): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_OUTPUT, Value));
end;

function TPromiseParams.OutputType(const Value: string): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_OUPUTTYPE, TOutputType.Create(Value).ToString));
end;

function TPromiseParams.OutputType(const Value: TOutputType): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_OUPUTTYPE, Value.ToString));
end;

function TPromiseParams.Pipeline(const Value: TObject): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_PIPELINE, Value));
end;

function TPromiseParams.ProcessingMode(const Value: string): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_PROCESSINGMODE, Value));
end;

function TPromiseParams.ProcessingMode(
  const Value: TProcessingMode): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_PROCESSINGMODE, Value.ToString));
end;

function TPromiseParams.SilentMode(const Value: Boolean): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_SILENTMODE, Value));
end;

function TPromiseParams.Model(const Value: string): TPromiseParams;
begin
  Result := TPromiseParams(Add(S_MODEL, Value));
end;

{ TChainOfThought }

class function TChainOfThought.New(const Content: string): TChainOfThought;
begin
  Result := TChainOfThought.Create;
  Result.Content := Content;
end;

{ TOutputTypeHelper }

constructor TOutputTypeHelper.Create(const Value: string);
begin
  try
    Self := TEnumValueRecovery.TypeRetrieve<TOutputType>(Value,
              ['json', 'none']);
  except
    Self := TOutputType.none;
  end;
end;

function TOutputTypeHelper.ToContent: string;
begin
  case self of
    TOutputType.json:
      Exit('Format the response as containerless JSON. Field names should be as descriptive as possible and should not be in camel notation.');
    TOutputType.none:
      Exit('');
  end;
end;

function TOutputTypeHelper.ToString: string;
begin
  case self of
    TOutputType.json:
      Exit('json');
    TOutputType.none:
      Exit('none');
  end;
end;

{ TEnumValueRecovery }

class function TEnumValueRecovery.TypeRetrieve<T>(const Value: string;
  const References: TArray<string>): T;
var
  pInfo: PTypeInfo;
begin
  pInfo := TypeInfo(T);
  if pInfo.Kind <> tkEnumeration then
    raise Exception.Create('TRecovery.TypeRetrieve<T>: T is not an enumerated type');

  var index := IndexStr(Value.ToLower, References);
  if index = -1 then
    raise Exception.CreateFmt('%s : Unable to retrieve enum value.', [Value]);

  Move(index, Result, SizeOf(Result));
end;

{ TPipeline }

function TPipeline.AggregatedOutput(isNew: Boolean): string;
begin
  if Count = 0 then
    Result := EmptyStr
  else
    begin
      if isNew then
        Result := Format('{"question": "%s"}', [Self.First.GetInput]);
      for var Item in Self do
        if Result.IsEmpty then
          Result := Item.GetOutput else
          Result := Result + sLineBreak + Item.GetOutput;
    end;
end;

constructor TPipeline.Create;
begin
  inherited Create(False);
  PromiseDataTrash.Add(Self);
end;

{ TChainOfThoughts }

constructor TChainOfThoughts.Create;
begin
  inherited Create;
  PromiseDataTrash.Add(Self);
end;

{ TPromiseEvents }

constructor TPromiseEvents.Create(AOwner: TPromiseParams);
begin
  inherited Create;
  FOwner := AOwner;

  {--- Link this instance to the the i-th step in the chain of thought }
  FOwner.Events(Self);

  {--- This instance is automatically destroy by the garbage collector }
  PromiseDataTrash.Add(Self);
end;

constructor TPromiseEvents.Create(ParamProc: TProc<TPromiseParams>);
begin
  var Data := TPromiseParams.Create;
  ParamProc(Data);
  Create(Data);
end;

{ TProcessingModeHelper }

constructor TProcessingModeHelper.Create(const Value: string);
begin
  try
    Self := TEnumValueRecovery.TypeRetrieve<TProcessingMode>(Value,
              ['web_normal', 'web_parallel', 'parallel', 'default']);
  except
    Self := TProcessingMode.default;
  end;
end;

function TProcessingModeHelper.ToString: string;
begin
  case self of
    TProcessingMode.web_normal:
      Exit('web_normal');
    TProcessingMode.web_parallel:
      Exit('web_parallel');
    TProcessingMode.parallel:
      Exit('parallel');
    TProcessingMode.default:
      Exit('default');
  end;
end;

end.
